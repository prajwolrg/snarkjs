package com.icon.score;

import score.Context;
import score.annotation.External;

import java.math.BigInteger;

public class Pairing {
    public static class G1Point {
        BigInteger X;
        BigInteger Y;

        public G1Point(BigInteger valueOf, BigInteger valueOf1) {
        }
    }

    // Encoding of field elements is: X[0] * z + X[1]
    public static class G2Point {
        BigInteger[] X;
        BigInteger[] Y;

        public G2Point(BigInteger[] arr1, BigInteger[] arr2) {
        }

    }

    public G1Point P1() {
        return new G1Point(
                new BigInteger("1"),
                new BigInteger("2")
        );
    }

    public static G1Point negate(G1Point p) {
        // The prime q in the base field F_q for G1
        BigInteger q = new BigInteger("21888242871839275222246405745257275088696311157297823662689037894645226208583");
        if (p.X.equals(BigInteger.ZERO) && p.Y.equals(BigInteger.ZERO)) {
            return new G1Point(
                    new BigInteger("0"),
                    new BigInteger("0")
            );
        }
        return new G1Point(
                p.X,
                q.subtract(p.Y.mod(q))
        );
    }

    public G2Point P2() {

        // Original code point
        return new G2Point(
                new BigInteger[]{
                        new BigInteger("11559732032986387107991004021392285783925812861821192530917403151452391805634"),
                        new BigInteger("10857046999023057135944570762232829481370756359578518086990519993285655852781")
                },
                new BigInteger[]{
                        new BigInteger("4082367875863433681332203403145435568316851327593401208105741076214120093531"),
                        new BigInteger("8495653923123431417604973247489272438418190587263600148770280649306958101930")
                });
    }

    public static byte[] getSliceOfArray(byte[] arr, int start, int end) {

        //TODO: check a better implementation
        // maybe java.util.Arrays? Java 8 Streams?

        // Get the slice of the Array
        byte[] slice = new byte[end - start];

        // Copy elements of arr to slice
        for (int i = 0; i < slice.length; i++) {
            slice[i] = arr[start + i];
        }

        // return the slice
        return slice;
    }

    public static G1Point bytesToG1Point(byte[] args) {
        Context.require(args.length == 64);
        return new G1Point(
                new BigInteger(getSliceOfArray(args, 0, 31)),
                new BigInteger(getSliceOfArray(args, 32, 63))
        );
    }

    public static G1Point addition(G1Point p1, G1Point p2) {
        byte[] res = Context.altBN128Add(p1.X, p1.Y, p2.X, p2.Y);
        return bytesToG1Point(res);
    }

    public static G1Point scalar_mul(G1Point p, BigInteger s) {
        byte[] res = Context.altBN128Mul(s, p.X, p.Y);
        return bytesToG1Point(res);
    }


    public static boolean pairing(G1Point[] p1, G2Point[] p2) {
        Context.require(p1.length == p2.length, "Pairing: G1 and G2 points must have same length");
        BigInteger[] p_x = new BigInteger[0];
        BigInteger[] p_y = new BigInteger[0];
        BigInteger[] p2_xr = new BigInteger[0];
        BigInteger[] p2_xi = new BigInteger[0];
        BigInteger[] p2_yr = new BigInteger[0];
        BigInteger[] p2_yi = new BigInteger[0];
        for (int i=0; i<p1.length; i++) {
            p_x[i] = p1[i].X;
            p_y[i] = p1[i].Y;
            p2_xr[i] = p2[i].X[0];
            p2_xi[i] = p2[i].X[1];
            p2_yr[i] = p2[i].Y[0];
            p2_yi[i] = p2[i].Y[1];
        }
        return Context.altBN128Pairing(p_x, p_y, p2_xr, p2_xi, p2_yr, p2_yi);
    }


    public boolean pairingProd2(G1Point a1, G2Point a2, G1Point b1, G2Point b2) {
        G1Point[] p1 = new G1Point[]{a1, b1};
        G2Point[] p2 = new G2Point[]{a2, b2};
        return pairing(p1, p2);
    }

    public boolean pairingProd3(G1Point a1, G2Point a2, G1Point b1, G2Point b2, G1Point c1, G2Point c2) {
        G1Point[] p1 = new G1Point[]{a1, b1, c1};
        G2Point[] p2 = new G2Point[]{a2, b2, c2};
        return pairing(p1, p2);
    }

    public static boolean pairingProd4(G1Point a1, G2Point a2, G1Point b1, G2Point b2, G1Point c1, G2Point c2, G1Point d1, G2Point d2) {
        G1Point[] p1 = new G1Point[]{a1, b1, c1, d1};
        G2Point[] p2 = new G2Point[]{a2, b2, c2, d2};
        return pairing(p1, p2);
    }

}

public class Verifier {
    class VerifyingKey {
        Pairing.G1Point alfa1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;

        Pairing.G1Point[] IC;
    }

    class Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;

    }

    public VerifyingKey verifyingKey () {
        VerifyingKey vk = new VerifyingKey();
        vk.alfa1 = new Pairing.G1Point(
                new BigInteger("<%=vk_alpha_1[0]%>"),
                new BigInteger("<%=vk_alpha_1[1]%>")
        );

        vk.beta2 = new Pairing.G2Point(
                new BigInteger[] {
                        new BigInteger("<%=vk_beta_2[0][1]%>"),
                        new BigInteger("<%=vk_beta_2[0][0]%>"),
                },
                new BigInteger[] {
                        new BigInteger("<%=vk_beta_2[1][1]%>"),
                        new BigInteger("<%=vk_beta_2[1][0]%>"),
                });

        vk.gamma2 = new Pairing.G2Point(
                new BigInteger[] {
                        new BigInteger("<%=vk_gamma_2[0][1]%>"),
                        new BigInteger("<%=vk_gamma_2[0][0]%>"),
                },
                new BigInteger[] {
                        new BigInteger("<%=vk_gamma_2[1][1]%>"),
                        new BigInteger("<%=vk_gamma_2[1][0]%>"),
                });

        vk.delta2 = new Pairing.G2Point(
                new BigInteger[] {
                        new BigInteger("<%=vk_delta_2[0][1]%>"),
                        new BigInteger("<%=vk_delta_2[0][0]%>"),
                },
                new BigInteger[] {
                        new BigInteger("<%=vk_delta_2[1][1]%>"),
                        new BigInteger("<%=vk_delta_2[1][0]%>"),
                });

        vk.IC = new Pairing.G1Point[] {
            <% for (let i=0; i<IC.length; i++) { %>
            new Pairing.G1Point( 
                new BigInteger("<%=IC[i][0]%>"),
                new BigInteger("<%=IC[i][1]%>"),
            ),
            <% } %>
        };

        return vk;
    }

    public int verify(BigInteger[] input, Proof proof) {
        BigInteger snark_scalar_field = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
        VerifyingKey vk = verifyingKey();
        Context.require(input.length + 1 == vk.IC.length, "verifier-bad-input");
        // Compute the linear combination vk_x
        Pairing.G1Point vk_x = new Pairing.G1Point(BigInteger.ZERO,BigInteger.ZERO);
        for (int i=0; i<input.length; i++) {
            Context.require(input[i].compareTo(snark_scalar_field) < 0, "verifier-gte-snark-scalar-field");
            vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[i+1], input[0]));
        }
        vk_x = Pairing.addition(vk_x, vk.IC[0]);
        if (!Pairing.pairingProd4(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2)) {
            return 1;
        }
        return 0;
    }

    @External(readonly = true)
    public boolean verifyProof(BigInteger[] a, BigInteger[][] b, BigInteger[] c, BigInteger[] input) {
        Proof proof = new Proof();
        proof.A = new Pairing.G1Point(a[0], a[1]);
        proof.B = new Pairing.G2Point(new BigInteger[]{b[0][0], b[0][1]}, new BigInteger[]{b[1][0], b[1][1]});
        proof.C = new Pairing.G1Point(c[0], c[1]);

        // TODO: Verify if copying is necessary
        if (verify(input, proof) == 0) {
            return true;
        } else {
            return false;
        }
    }
}
