package com.icon.score;

import score.Context;
import score.annotation.External;

import java.math.BigInteger;

public class Pairing {
    public static class G1Point {
        BigInteger X;
        BigInteger Y;

        public G1Point(BigInteger valueOf, BigInteger valueOf1) {
        }
    }

    // Encoding of field elements is: X[0] * z + X[1]
    public static class G2Point {
        final BigInteger[] X = new BigInteger[2];
        final BigInteger[] Y = new BigInteger[2];

        public G2Point(BigInteger[] arr1, BigInteger[] arr2) {
        }

    }

    public G1Point P1() {
        return new G1Point(
                new BigInteger("1"),
                new BigInteger("2")
        );
    }

    public static G1Point negate(G1Point p) {
        // The prime q in the base field F_q for G1
        BigInteger q = new BigInteger("21888242871839275222246405745257275088696311157297823662689037894645226208583");
        if (p.X.equals(BigInteger.ZERO) && p.Y.equals(BigInteger.ZERO)) {
            return new G1Point(
                    new BigInteger("0"),
                    new BigInteger("0")
            );
        }
        return new G1Point(
                p.X,
                q.subtract(p.Y.mod(q))
        );
    }

    public G2Point P2() {

        // Original code point
        return new G2Point(
                new BigInteger[]{
                        new BigInteger("11559732032986387107991004021392285783925812861821192530917403151452391805634"),
                        new BigInteger("10857046999023057135944570762232829481370756359578518086990519993285655852781")
                },
                new BigInteger[]{
                        new BigInteger("4082367875863433681332203403145435568316851327593401208105741076214120093531"),
                        new BigInteger("8495653923123431417604973247489272438418190587263600148770280649306958101930")
                });
    }

    public static byte[] getSliceOfArray(byte[] arr, int start, int end) {

        //TODO: check a better implementation
        // maybe java.util.Arrays? Java 8 Streams?

        // Get the slice of the Array
        byte[] slice = new byte[end - start];

        // Copy elements of arr to slice
        for (int i = 0; i < slice.length; i++) {
            slice[i] = arr[start + i];
        }

        // return the slice
        return slice;
    }

    public static G1Point bytesToG1Point(byte[] args) {
        Context.require(args.length == 64);
        return new G1Point(
                new BigInteger(getSliceOfArray(args, 0, 31)),
                new BigInteger(getSliceOfArray(args, 32, 63))
        );
    }

    public static byte[] concatBytes(byte[] a, byte[] b) {

        byte[] c = new byte[a.length + b.length];
        System.arraycopy(a,0,c,0,a.length);
        System.arraycopy(b,0,c,a.length, b.length);
        return c;
    }

    public static byte[] G1PointToBytes(G1Point p) {
        byte[] a = p.X.toByteArray();
        byte[] b = p.Y.toByteArray();
        return concatBytes(a, b);
    }

    public static byte[] G2PointToBytes(G2Point p) {
        byte[] a = p.X.toByteArray();
        byte[] b = p.Y.toByteArray();
        return concatBytes(a, b);
    }

    public static G1Point addition(G1Point p1, G1Point p2) {
        byte[] res = Context.bn256("add",
                concatBytes(
                        G1PointToBytes(p1),
                        G1PointToBytes(p2)
                )
        );
        return bytesToG1Point(res);
    }

    public static G1Point scalar_mul(G1Point p, BigInteger s) {
        byte[] res = Context.bn256("mul",
                concatBytes(
                        G1PointToBytes(p),
                        s.toByteArray()
                ));
        return bytesToG1Point(res);
    }

    public static boolean pairing(G1Point[] p1, G2Point[] p2) {
        Context.require(p1.length == p2.length, "Pairing: G1 and G2 points must have same length");
        Context.require(p1.length > 0, "Paring: Must have some points");

        byte[] arg = new byte[0];
        for (int i=1; i<p1.length; i++) {
            arg = concatBytes(
                    arg,
                    concatBytes(
                            concatBytes(
                                    p1[0].X.toByteArray(),
                                    p1[0].Y.toByteArray()
                            ),
                            concatBytes(
                                    concatBytes(
                                            p2[0].X[0].toByteArray(),
                                            p2[0].X[1].toByteArray()
                                    ),
                                    concatBytes(
                                            p2[0].Y[0].toByteArray(),
                                            p2[0].Y[1].toByteArray()
                                    )
                            )
                    )
            );
        }

        byte[] res = Context.bn256("pairing", arg);
        if (res[0] == 1) {
            return true;
        } else {
            return false;
        }
    }

    public boolean pairingProd2(G1Point a1, G2Point a2, G1Point b1, G2Point b2) {
        G1Point[] p1 = new G1Point[]{a1, b1};
        G2Point[] p2 = new G2Point[]{a2, b2};
        return pairing(p1, p2);
    }

    public boolean pairingProd3(G1Point a1, G2Point a2, G1Point b1, G2Point b2, G1Point c1, G2Point c2) {
        G1Point[] p1 = new G1Point[]{a1, b1, c1};
        G2Point[] p2 = new G2Point[]{a2, b2, c2};
        return pairing(p1, p2);
    }

    public static boolean pairingProd4(G1Point a1, G2Point a2, G1Point b1, G2Point b2, G1Point c1, G2Point c2, G1Point d1, G2Point d2) {
        G1Point[] p1 = new G1Point[]{a1, b1, c1, d1};
        G2Point[] p2 = new G2Point[]{a2, b2, c2, d2};
        return pairing(p1, p2);
    }

}
public class Verifier {
    class VerifyingKey {
        Pairing.G1Point alfa1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;

        Pairing.G1Point[] IC;
    }

    class Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;

    }

    public VerifyingKey verifyingKey () {
        VerifyingKey vk = new VerifyingKey();
        vk.alfa1 = new Pairing.G1Point(
                new BigInteger("<%=vk_alpha_1[0]%>"),
                new BigInteger("<%=vk_alpha_1[1]%>")
        );

        vk.beta2 = new Pairing.G2Point(
                new BigInteger[] {
                        new BigInteger("<%=vk_beta_2[0][1]%>"),
                        new BigInteger("<%=vk_beta_2[0][0]%>"),
                },
                new BigInteger[] {
                        new BigInteger("<%=vk_beta_2[1][1]%>"),
                        new BigInteger("<%=vk_beta_2[1][0]%>"),
                });

        vk.gamma2 = new Pairing.G2Point(
                new BigInteger[] {
                        new BigInteger("<%=vk_gamma_2[0][1]%>"),
                        new BigInteger("<%=vk_gamma_2[0][0]%>"),
                },
                new BigInteger[] {
                        new BigInteger("<%=vk_gamma_2[1][1]%>"),
                        new BigInteger("<%=vk_gamma_2[1][0]%>"),
                });

        vk.delta2 = new Pairing.G2Point(
                new BigInteger[] {
                        new BigInteger("<%=vk_delta_2[0][1]%>"),
                        new BigInteger("<%=vk_delta_2[0][0]%>"),
                },
                new BigInteger[] {
                        new BigInteger("<%=vk_delta_2[1][1]%>"),
                        new BigInteger("<%=vk_delta_2[1][0]%>"),
                });

        vk.IC = new Pairing.G1Point[] {
            <% for (let i=0; i<IC.length; i++) { %>
            new Pairing.G1Point( 
                new BigInteger("<%=IC[i][0]%>"),
                new BigInteger("<%=IC[i][1]%>"),
            ),
            <% } %>
        };

        return vk;
    }

    public int verify(BigInteger[] input, Proof proof) {
        BigInteger snark_scalar_field = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
        VerifyingKey vk = verifyingKey();
        Context.require(input.length + 1 == vk.IC.length, "verifier-bad-input");
        // Compute the linear combination vk_x
        Pairing.G1Point vk_x = new Pairing.G1Point(BigInteger.ZERO,BigInteger.ZERO);
        for (int i=0; i<input.length; i++) {
            Context.require(input[i].compareTo(snark_scalar_field) < 0, "verifier-gte-snark-scalar-field");
            vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[i+1], input[0]));
        }
        vk_x = Pairing.addition(vk_x, vk.IC[0]);
        if (!Pairing.pairingProd4(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2)) {
            return 1;
        }
        return 0;
    }

    @External(readonly = true)
    public boolean verifyProof(BigInteger[] a, BigInteger[][] b, BigInteger[] c, BigInteger[] input) {
        Proof proof = new Proof();
        proof.A = new Pairing.G1Point(a[0], a[1]);
        proof.B = new Pairing.G2Point(new BigInteger[]{b[0][0], b[0][1]}, new BigInteger[]{b[1][0], b[1][1]});
        proof.C = new Pairing.G1Point(c[0], c[1]);

        // TODO: Verify if copying is necessary
        if (verify(input, proof) == 0) {
            return true;
        } else {
            return false;
        }
    }
}
